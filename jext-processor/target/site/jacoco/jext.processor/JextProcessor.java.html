<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>JextProcessor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">jExt Annotation Processor</a> &gt; <a href="index.source.html" class="el_package">jext.processor</a> &gt; <span class="el_source">JextProcessor.java</span></div><h1>JextProcessor.java</h1><pre class="source lang-java linenums">/**
 * @author Luis IÃ±esta Gelabert - luiinge@gmail.com
 */
package jext.processor;


import static java.util.stream.Collectors.*;
import java.util.*;
import java.util.stream.*;
import javax.annotation.processing.*;
import javax.lang.model.SourceVersion;
import javax.lang.model.element.*;
import javax.lang.model.element.ModuleElement.*;
import javax.lang.model.type.TypeMirror;
import javax.tools.Diagnostic.Kind;
import jext.*;

/**
 * An extension processor that validate and publish the provided extensions
 */
@SupportedAnnotationTypes({
    &quot;jext.Extension&quot;,
    &quot;jext.ExtensionPoint&quot;
})
@SupportedSourceVersion(SourceVersion.RELEASE_11)
<span class="fc" id="L26">public class JextProcessor extends AbstractProcessor {</span>


    private static class ExtensionInfo {

        private final TypeElement extensionElement;
        private final String extensionName;
        private final TypeElement extensionPointElement;
        private final String extensionPointName;

<span class="fc" id="L36">        public ExtensionInfo(</span>
            TypeElement extensionElement,
            String extensionName,
            TypeElement extensionPointElement,
            String extensionPointName
        ) {
<span class="fc" id="L42">            this.extensionElement = extensionElement;</span>
<span class="fc" id="L43">            this.extensionName = extensionName;</span>
<span class="fc" id="L44">            this.extensionPointElement = extensionPointElement;</span>
<span class="fc" id="L45">            this.extensionPointName = extensionPointName;</span>
<span class="fc" id="L46">        }</span>
    }


    private ProcessingHelper helper;



    @SuppressWarnings(&quot;exports&quot;)
    @Override
    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {

<span class="fc" id="L58">        this.helper = new ProcessingHelper(processingEnv);</span>

<span class="fc bfc" id="L60" title="All 2 branches covered.">        if (!annotations.isEmpty()) {</span>
<span class="fc" id="L61">            Map&lt;String, List&lt;String&gt;&gt; serviceImplementations = new LinkedHashMap&lt;&gt;();</span>
<span class="fc" id="L62">            validateAndRegisterExtensions(roundEnv, serviceImplementations);</span>
<span class="fc" id="L63">            validateExtensionPoints(roundEnv);</span>
<span class="fc bfc" id="L64" title="All 2 branches covered.">            if (!validateModule(roundEnv, serviceImplementations)) {</span>
<span class="fc" id="L65">                return false;</span>
            }
        } else {
<span class="fc" id="L68">            new ManifestGeneratorProcessor().process(processingEnv, roundEnv);</span>
        }
<span class="fc" id="L70">        return true;</span>
    }






    private void validateAndRegisterExtensions(
        RoundEnvironment roundEnv,
        Map&lt;String, List&lt;String&gt;&gt; serviceImplementations
    ) {
<span class="fc bfc" id="L82" title="All 2 branches covered.">        for (Element extensionElement : roundEnv.getElementsAnnotatedWith(Extension.class)) {</span>
<span class="pc bpc" id="L83" title="1 of 2 branches missed.">            if (validateElementKindIsClass(extensionElement)) {</span>
<span class="fc" id="L84">                validateAndRegisterExtension(</span>
<span class="fc" id="L85">                    (TypeElement) extensionElement, serviceImplementations</span>
                );
            }
        }
<span class="fc" id="L89">    }</span>


    private void validateExtensionPoints(RoundEnvironment roundEnv) {
<span class="fc" id="L93">        var extensionPoints = roundEnv.getElementsAnnotatedWith(ExtensionPoint.class);</span>
<span class="fc bfc" id="L94" title="All 2 branches covered.">        for (Element extensionPointElement : extensionPoints) {</span>
<span class="fc" id="L95">            validateExtensionPoint(extensionPointElement);</span>
        }
<span class="fc" id="L97">    }</span>


    private void validateExtensionPoint(Element extensionPointElement) {
<span class="pc bpc" id="L101" title="1 of 2 branches missed.">        if (extensionPointElement.getKind() != ElementKind.CLASS &amp;&amp;</span>
<span class="pc bpc" id="L102" title="1 of 2 branches missed.">            extensionPointElement.getKind() != ElementKind.INTERFACE</span>
        ) {
<span class="nc" id="L104">            helper.log(</span>
<span class="nc" id="L105">                Kind.ERROR,</span>
<span class="nc" id="L106">                extensionPointElement,</span>
<span class="nc" id="L107">                &quot;@ExtensionPoint not valid for {} (only processed for classes or interfaces)&quot;,</span>
<span class="nc" id="L108">                extensionPointElement.getSimpleName()</span>
            );
<span class="nc" id="L110">        } else {</span>
<span class="fc" id="L111">            var annotation = extensionPointElement.getAnnotation(ExtensionPoint.class);</span>
<span class="fc" id="L112">            validateVersionFormat(</span>
<span class="fc" id="L113">                annotation.version(), extensionPointElement, &quot;version&quot;</span>
            );
        }
<span class="fc" id="L116">    }</span>



    private boolean validateModule(
        RoundEnvironment roundEnv,
        Map&lt;String, List&lt;String&gt;&gt; serviceImplementations
    ) {
<span class="fc" id="L124">        var elements = roundEnv.getElementsAnnotatedWithAny(Set.of(ExtensionPoint.class,Extension.class));</span>
<span class="pc bpc" id="L125" title="1 of 2 branches missed.">        if (elements.isEmpty()) {</span>
<span class="nc" id="L126">            return true;</span>
        }
<span class="fc" id="L128">        var module = processingEnv.getElementUtils().getModuleOf(</span>
<span class="fc" id="L129">            elements.iterator().next()</span>
        );
<span class="fc" id="L131">        boolean ok = true;</span>

<span class="fc" id="L133">        var exports = directives(module, ExportsDirective.class);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (var extensionPoint : roundEnv.getElementsAnnotatedWith(ExtensionPoint.class)) {</span>
<span class="pc bpc" id="L135" title="1 of 4 branches missed.">            ok = ok &amp;&amp; validateModuleExtensionPoint(extensionPoint,exports);</span>
        }

<span class="fc" id="L138">        var provides = directives(module, ProvidesDirective.class);</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        for (var entry : serviceImplementations.entrySet()) {</span>
<span class="pc bpc" id="L140" title="1 of 4 branches missed.">            ok = ok &amp;&amp; validateModuleExtension(entry.getKey(), entry.getValue(), provides);</span>
        }

<span class="fc" id="L143">        return ok;</span>
    }



    private boolean validateModuleExtensionPoint(
        Element extensionPoint,
        List&lt;ExportsDirective&gt; exports
    ) {
<span class="fc" id="L152">        var extensionPointPackage = processingEnv.getElementUtils().getPackageOf(extensionPoint);</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">        if (exports.stream().map(ExportsDirective::getPackage).noneMatch(extensionPointPackage::equals)) {</span>
<span class="fc" id="L154">            var message = new StringBuilder();</span>
<span class="fc" id="L155">            message.append(&quot;Extension point package {} must be declared in the module-info.java file:\n\n&quot;);</span>
<span class="fc" id="L156">            message.append(&quot;\texports {};\n&quot;);</span>
<span class="fc" id="L157">            helper.log(Kind.ERROR, message.toString(),extensionPointPackage,extensionPointPackage);</span>
<span class="fc" id="L158">            return false;</span>
        }
<span class="fc" id="L160">        return true;</span>
    }




    private boolean validateModuleExtension(
        String extensionPoint,
        List&lt;String&gt; extensions,
        List&lt;ProvidesDirective&gt; provides
    ) {
<span class="fc" id="L171">        var implementations = provides.stream()</span>
<span class="fc" id="L172">            .filter(directive -&gt; nameEquals(directive.getService(),extensionPoint))</span>
<span class="fc" id="L173">            .flatMap(directive -&gt; directive.getImplementations().stream())</span>
<span class="fc" id="L174">            .map(TypeElement::getQualifiedName)</span>
<span class="fc" id="L175">            .map(Object::toString)</span>
<span class="fc" id="L176">            .collect(Collectors.toList());</span>

<span class="fc" id="L178">        var nonDeclared = extensions.stream()</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">            .filter(extension -&gt; !implementations.contains(extension))</span>
<span class="fc" id="L180">            .collect(toList());</span>

<span class="fc bfc" id="L182" title="All 2 branches covered.">        if (!nonDeclared.isEmpty()) {</span>
<span class="fc" id="L183">            var message = new StringBuilder();</span>
<span class="fc" id="L184">            message.append(&quot;Extensions implementing extension point {} must be declared in the module-info.java file:\n\n&quot;);</span>
<span class="fc" id="L185">            message.append(&quot;\tprovides {} with&quot;);</span>
<span class="pc bpc" id="L186" title="2 of 4 branches missed.">            if (implementations.isEmpty() &amp;&amp; nonDeclared.size() == 1) {</span>
<span class="nc" id="L187">                message.append(extensions.get(0)).append(&quot;;\n\n&quot;);</span>
<span class="nc" id="L188">            } else {</span>
<span class="fc" id="L189">                message.append(</span>
<span class="fc" id="L190">                    Stream.concat(implementations.stream(),nonDeclared.stream())</span>
<span class="fc" id="L191">                    .collect(joining(&quot;,\n\t\t&quot;, &quot;\n\t\t&quot;, &quot;;\n\n&quot;))</span>
                );
            }
<span class="fc" id="L194">            helper.log(Kind.ERROR, message.toString(),extensionPoint,extensionPoint);</span>
<span class="fc" id="L195">            return false;</span>
        } else {
<span class="fc" id="L197">            return true;</span>
        }
    }


    private boolean nameEquals(TypeElement element, String name) {
<span class="fc" id="L203">        return element.getQualifiedName().contentEquals(name);</span>
    }





    private &lt;T extends Directive&gt; List&lt;T&gt; directives(ModuleElement module, Class&lt;T&gt; type) {
<span class="fc" id="L211">        return module.getDirectives()</span>
<span class="fc" id="L212">            .stream()</span>
<span class="fc" id="L213">            .filter(type::isInstance)</span>
<span class="fc" id="L214">            .map(type::cast)</span>
<span class="fc" id="L215">            .collect(Collectors.toList());</span>
    }




    private void validateAndRegisterExtension(
        TypeElement extensionElement,
        Map&lt;String, List&lt;String&gt;&gt; serviceImplementations
    ) {

<span class="fc" id="L226">        boolean ignore = false;</span>
<span class="fc" id="L227">        var extensionAnnotation = extensionElement.getAnnotation(Extension.class);</span>

        // not handling externally managed extensions
        //ignore = extensionAnnotation.externallyManaged();
<span class="pc bpc" id="L231" title="1 of 2 branches missed.">        ignore = ignore || !validateVersionFormat(</span>
<span class="fc" id="L232">            extensionAnnotation.extensionPointVersion(),</span>
<span class="fc" id="L233">            extensionElement,</span>
<span class="fc" id="L234">            &quot;extensionPointVersion&quot;</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">        );</span>

<span class="pc bpc" id="L237" title="1 of 2 branches missed.">        if (ignore) {</span>
<span class="nc" id="L238">            return;</span>
        }

<span class="fc" id="L241">        String extensionPointName = computeExtensionPointName(</span>
<span class="fc" id="L242">            extensionElement, extensionAnnotation</span>
        );
<span class="fc" id="L244">        String extensionName = extensionElement.getQualifiedName().toString();</span>
<span class="fc" id="L245">        TypeElement extensionPointElement = processingEnv.getElementUtils()</span>
<span class="fc" id="L246">            .getTypeElement(extensionPointName);</span>
<span class="fc" id="L247">        ExtensionInfo extensionInfo = new ExtensionInfo(</span>
<span class="fc" id="L248">            extensionElement,</span>
<span class="fc" id="L249">            extensionName,</span>
<span class="fc" id="L250">            extensionPointElement,</span>
<span class="fc" id="L251">            extensionPointName</span>
        );

<span class="pc bpc" id="L254" title="1 of 2 branches missed.">        ignore = !validateExtensionPointClassExists(extensionInfo);</span>
<span class="pc bpc" id="L255" title="1 of 4 branches missed.">        ignore = ignore || !validateExtensionPointAnnotation(extensionInfo);</span>
<span class="fc bfc" id="L256" title="All 4 branches covered.">        ignore = ignore || !validateExtensionPointAssignableFromExtension(extensionInfo);</span>

<span class="fc bfc" id="L258" title="All 2 branches covered.">       if (!ignore) {</span>
<span class="fc" id="L259">            serviceImplementations</span>
<span class="fc" id="L260">                .computeIfAbsent(extensionPointName, x -&gt; new ArrayList&lt;&gt;())</span>
<span class="fc" id="L261">                .add(extensionName);</span>
        }

<span class="fc" id="L264">    }</span>




    private boolean validateExtensionPointAssignableFromExtension(ExtensionInfo extensionInfo) {
<span class="fc" id="L270">        if (!isAssignable(</span>
<span class="fc" id="L271">            extensionInfo.extensionElement.asType(), extensionInfo.extensionPointElement.asType()</span>
<span class="fc bfc" id="L272" title="All 2 branches covered.">        )) {</span>
<span class="fc" id="L273">            helper.log(</span>
<span class="fc" id="L274">                Kind.ERROR,</span>
<span class="fc" id="L275">                extensionInfo.extensionElement,</span>
<span class="fc" id="L276">                &quot;{} must implement or extend the extension point type {}&quot;,</span>
<span class="fc" id="L277">                extensionInfo.extensionName,</span>
<span class="fc" id="L278">                extensionInfo.extensionPointName</span>
            );
<span class="fc" id="L280">            return false;</span>
        }
<span class="fc" id="L282">        return true;</span>
    }


    private boolean validateExtensionPointAnnotation(ExtensionInfo extensionInfo) {
<span class="fc bfc" id="L287" title="All 2 branches covered.">        if (extensionInfo.extensionPointElement.getAnnotation(ExtensionPoint.class) == null) {</span>
<span class="fc" id="L288">            helper.log(</span>
<span class="fc" id="L289">                Kind.ERROR,</span>
<span class="fc" id="L290">                extensionInfo.extensionElement,</span>
<span class="fc" id="L291">                &quot;Expected extension point type '{}' is not annotated with @ExtensionPoint&quot;,</span>
<span class="fc" id="L292">                extensionInfo.extensionPointName</span>
            );
<span class="fc" id="L294">            return false;</span>
        }
<span class="fc" id="L296">        return true;</span>
    }


    private boolean validateExtensionPointClassExists(ExtensionInfo extensionInfo) {
<span class="pc bpc" id="L301" title="1 of 2 branches missed.">        if (extensionInfo.extensionPointElement == null) {</span>
<span class="nc" id="L302">            helper.log(</span>
<span class="nc" id="L303">                Kind.ERROR,</span>
<span class="nc" id="L304">                extensionInfo.extensionElement,</span>
<span class="nc" id="L305">                &quot;Cannot find extension point class '{}'&quot;,</span>
<span class="nc" id="L306">                extensionInfo.extensionPointName</span>
            );
<span class="nc" id="L308">            return false;</span>
        }
<span class="fc" id="L310">        return true;</span>
    }


    private String computeExtensionPointName(
        TypeElement extensionClassElement,
        Extension extensionAnnotation
    ) {
<span class="fc" id="L318">        String extensionPoint = extensionAnnotation.extensionPoint();</span>
<span class="fc bfc" id="L319" title="All 2 branches covered.">        if (extensionPoint.isEmpty()) {</span>
<span class="fc bfc" id="L320" title="All 2 branches covered.">            for (TypeMirror implementedInterface : extensionClassElement.getInterfaces()) {</span>
<span class="fc" id="L321">                extensionPoint = implementedInterface.toString();</span>
                // remove the &lt;..&gt; part in case it is a generic class
<span class="fc" id="L323">                extensionPoint = extensionPoint.replaceAll(&quot;\\&lt;[^\\&gt;]*\\&gt;&quot;, &quot;&quot;);</span>
            }
        }
<span class="fc" id="L326">        return extensionPoint;</span>
    }


    boolean validateElementKindIsClass(Element element) {
<span class="pc bpc" id="L331" title="1 of 2 branches missed.">        if (element.getKind() != ElementKind.CLASS) {</span>
<span class="nc" id="L332">            helper.log(</span>
<span class="nc" id="L333">                Kind.WARNING,</span>
<span class="nc" id="L334">                element,</span>
<span class="nc" id="L335">                &quot;@Extension ignored for {} (only processed for classes)&quot;,</span>
<span class="nc" id="L336">                element.getSimpleName()</span>
            );
<span class="nc" id="L338">            return false;</span>
        }
<span class="fc" id="L340">        return true;</span>
    }


    private boolean validateVersionFormat(String version, Element element, String fieldName) {
<span class="fc" id="L345">        boolean valid = SemanticVersion.validate(version);</span>
<span class="fc bfc" id="L346" title="All 2 branches covered.">        if (!valid) {</span>
<span class="fc" id="L347">            helper.log(</span>
<span class="fc" id="L348">                Kind.ERROR,</span>
<span class="fc" id="L349">                element,</span>
<span class="fc" id="L350">                &quot;Content of field {} ('{}') must be in form of semantic version: '&lt;major&gt;.&lt;minor&gt;[.&lt;patch&gt;]'&quot;,</span>
<span class="fc" id="L351">                fieldName,</span>
<span class="fc" id="L352">                version</span>
            );
        }
<span class="fc" id="L355">        return valid;</span>
    }


    private boolean isAssignable(TypeMirror type, TypeMirror typeTo) {
<span class="fc bfc" id="L360" title="All 2 branches covered.">        if (nameWithoutGeneric(type).equals(nameWithoutGeneric(typeTo))) {</span>
<span class="fc" id="L361">            return true;</span>
        }
<span class="fc bfc" id="L363" title="All 2 branches covered.">        for (TypeMirror superType : processingEnv.getTypeUtils().directSupertypes(type)) {</span>
<span class="fc bfc" id="L364" title="All 2 branches covered.">            if (isAssignable(superType, typeTo)) {</span>
<span class="fc" id="L365">                return true;</span>
            }
        }
<span class="fc" id="L368">        return false;</span>
    }


    private String nameWithoutGeneric(TypeMirror type) {
<span class="fc" id="L373">        int genericPosition = type.toString().indexOf('&lt;');</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">        return genericPosition&lt;0 ? type.toString() : type.toString().substring(0, genericPosition);</span>
    }







}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.2.201808211720</span></div></body></html>